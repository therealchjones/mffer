Development Notes

I started trying to reverse engineer Marvel Future Fight somewhere around
version 6.2.0, or at least those are the first archives I have of anything even
remotely useful. I started with the x86 build, which I probably didn't put much
thought into choosing as it would clearly be the one with which I had the most
experience (regardless of that experience not mattering in the least). As it
happens, sometime between 6.2.0 and 6.7.0, the gap which spanned from my first
attempts to get usable information to the first time I was ready to generalize
those attempts into extracting information from a new version, Netmarble stopped
releasing x86 builds; installing Future Fight from the Play Store on an x86
emulator installed the armeabi-v7a build instead, since it was compatible with
the x86 devices. As the assembly language for ARM appeared to be quite different
from that for x86, I hoped I could continue to use the x86 assembly knowledge
which I'd had to learn by using the x86_64 build instead.

Unfortunately, the x86_64 APKs I downloaded from the Google Play Store would not
run on the emulators when I installed them. They crashed due to an inability to
locate libnmsssa.so, a security library Netmarble installed---or was supposed
to. As it turned out, all the x86_64 APKs, at least back to 6.2.0, included none
of the actual architecture-specific libraries for the game. Hoping this was some
sort of difficulty with how the Play Store "repackaged" APKs from large bundles
that had been uploaded, I tried using different accounts, changing to different
emulator devices, and even researching how to change the identifiers for the
emulator so that the Play Store wouldn't recognize it as a device that had
previously installed the software. I couldn't get it to work. Turning to the APK
sharing sites like APKmirror.com, I found all their x86_64 APKs had the same
problem. I had written to in-game support for assistance, only to essentially
receive a form letter saying everything installed fine, and if there was a
problem it was because I was using an emulator rather than a physical device.
And, of course, I couldn't come up with any ideas for proving this incorrect
rather than actually obtaining an x86_64 physical device.

I'd love to ask for help, but the situation is too niche for StackOverflow (and
not exactly a *developer* problem), and probably far too technical for the
reddit Future Fight forum. Maybe Google/Android/Play Store would be interested
in the unusable APK being distributed for certain architectures.

Posted variations to Google Play Store help request & community:

Marvel Future Fight x86_64 APK does not include libraries

Using Android SDK emulator with x86_64 system image with Google Play API (system-images;android-30;google_apis_playstore;x86_64), open Play Store app, login, install Marvel Future Fight (com.netmarble.mherosgb). Open Marvel Future Fight, almost immediate crash. Further investigation reveals the crash is an UnsatisfiedLinkError due to a missing libnmsssa.so. No such file exists in the delivered (and surprisingly small) split_config.x86_64.apk as part of the installation. However, this file (and many other architecture-dependent libraries) are included in the armeabi-v7a APK (which is also used on x86) and the arm64-v8a; they just don't seem to be included in the x86_64 APK, making running on that platform impossible. Reviewing this split APK on several (admittedly less reputable) sites suggests this same problem goes back several versions/releases. Developer states this is due to emulator use, but it appears the package does not properly support x86_64.

I have brought this problem to the attention of the developer via in-game issue filing, but they state that it is due to using an emulator, and that all works properly on physical devices. Unfortunately, I am unable to confirm this, and thus unable to determine if this is a bug in the Play Store delivery or in the packaging uploaded to the Play Store. Either way, it appears that x86_64 devices are not properly supported as the Play Store package description would suggest. Please determine whether there is an easy fix or if x86_64 compatibility should be removed from the package.

I'm happy to provide any further information that may be of use.

--


installed ghidra
changed ghidra.bat to use 2048MB memory
installed amazon coretto 11 for windows
used adoptopenjdk on mac

Ghidra -> New Project -> Batch Import ->
        device/data/app/*/*/lib/x86/* -> open libil2cpp.so
(or maybe just load il2cppdumper then others until symbols are resolved?)
(or maybe libil2cpp.so is all I need, and accept unresolved symbols)

When to analyze?
When Ghidra has completed analysis,
        Window -> Script Manager -> Script Directories ->
                add il2cppdumper directory, run ghidra.py and select the
                        requested files from the il2cppdumper directory
(turn off analyzers while running script, close all windows including listing, leaving just Console and script manager open)

got all files findable by root in a netmarble path, zipped to allfiles.tar.gz
(some nmss sockets unable to be taken)
compared base & split apk from google play avd to new one in allfiles, same, deleted the former
(also made sure there were no other files with user u0_a149, group u0_a149, or group u0_a149_cache)
pruned subtrees that were identical, got down to just the /data directory

decompiled .apk files and the .dex files within them to decompiled/, combined (mostly) the split and base dirs, combined the classes dirs

need to decompile odex and vdex files; base.vdex contained only (optimized) copies of the classes.dex and classes2.dex files. (used vdexExtractor) Used baksmali, then smali, then decompiler.com to decompile base.odex->out(smalis)->out.dex->odex-sources/, merged new files (constants et al.) with decompiled/base/sources. All the rest are at least cosmetically different (fail cmp), left in decompiled/base-odex/sources. All the rest are at least cosmetically different (fail cmp), left in decompiled/base-odex/sources.

need to check (a separate copy of) decompiled and/or device for assets/bundles

Asset Studio:
decompiled/ : a few text assets including localization, RPC?, sounds, scenes?, fonts (including confirmation primary font is Exo Condensed and (maybe) Arial, Visitor TT1 Extended, and Exo CJKs)
device/data/media/0/Android/data/com.netmarble.mherosgb/files/
	bundle_each: audio, promo images
	bundle: lots and lots, haven't yet loaded all successfully
		_common*: mostly crap textures, a couple of head shots
		_scene*: crap textures
		_unit*: crap textrues
		effect*: nothing useful
		fx,item,localization*: localization_en TextAsset with strings
		monster, scene_*: useless textures
		sound: well, sound
		stringTable_en.csv: extracted version of Localization_en.csz
		text: mostly encoded(?) textassets
		ui_*: various icons, backgrounds
			ui_card: small comic card images (128x128)
			ui_characterani: special moving icon images
			ui_character: head shots
			ui_comicscard: larger comic cards in combined atlas-like images
		unit_*: character textures

Looking for: text, comic cards, headshots, shadowland headshots, uniform headshots

obtained apktool, used to decompile base.apk, should use this and compare to decompiler.com

loaded device/data/media/0/Android/data/com.netmarble.mherosgb/files/bundle into AssetStudioGUI (which took a very long time)

Discovery utilities:
Il2CppDumper
IlSpy
DnSpy?
VC_redist?
android studio (not emulated)
apktool?
vdexextractor?
AssetStudioGUI
Decompiler.com?

Ongoing utilities:
Android Studio (device emulator, java, adb)
Asset extractor

--
grep -Rl 'CO-OP PLAY' device/ > co-op_play_files
# only device/data/media/0/Android/data/com.netmarble.mherosgb/files/bundle/
# localization_{in,ar,en} and stringTable_en.csv
# Opening localization_en in AssetStudioGUI yields only one asset/file,
# localization/localization_en.csv. Export this, cmp exactly the same as
# stringTable_en.csv
# reading file, header is just "prevent clipping" and "dummy"
# interesting places 'CO-OP PLAY' comes in:
# MULTI_03 CO-OP PLAY
# FUTURE_PASS_CONTENTS_19 [CO-OP PLAY] Acquire a reward
# ACHIEVE_1016140 AVENGERS ASSEMBLE! #1
# ACHIEVE_DESC_1016140 [CO-OP PLAY] Participate 1 time
# ACHIEVE_2001060 [DAILY] THE IMPORTANCE OF TEAMWORK
# ACHIEVE_DESC_2001060 [CO-OP PLAY] 5 Successful Completions

# Looking for associated strings in multiple areas: see MFF spreadsheet
# "String RE" tab
--
Need:
Android Studio, Android NDK
device-netmarble files

mkdir lib-android/
cp -a ~/Library/Android/sdk/ndk/21.3.6528147/toolchains/llvm/prebuilt/darwin-x86_64/sysroot/usr/lib/i686-linux-android/28/*.so lib-android/

ghidra make new project
	import libil2cpp.so from device-netmarble files
		options:
			changing start/base to 0
			load libraries, add lib-android/ directory
	open libil2cpp.so from ghidra project tree
		autoanalyze when prompted
			include all default options except:
				discovery of nonreturn functions
				embedded media
				call convention identification
			add elf scalar operand references
			(check if this is right for defaults:
				all except red, nonreturning discovery,
				call convention, decompiler parameter id,
				and embedded media)
		(lots of LSDA errors in FDE territory with address
			overflow in subtract; this may be related to the
			above elf thing; should we allow the different/default
			base?)

use il2cpp-hmaker to make il2cpp-fixed.h
ghidra: explore and follow DBTable classes
(of note, libil2cpp.so seems to have had all relocation data stripped from it as well, resulting in all the e8 00 00 00 00 calls.)
Oh, no, that's not the deal, it's just a really weird way to figure out where some of the plt is found
then, Parse struct file, run ghidra script, auto-analyze again(?), and follow DBTable class functions
had to expand ghidra memory to 4gb, vm to 8gb

maybe il2cppdumper script would work better without "const" in function definitions?
--
Unzipped *.apk to apk/
Loaded *.apk to decompiler.com, downloaded zip, unzipped to apk-decompiled/
Unzipped prior decompiler.com version of *.apk to apk-decompiled-2/
Compared those final two versions (diff -qr apk-decomp*), copied two files that differed from apk-decompiled-2 to <path/filename-2> under apk-decompiled
Removed apk-decompiled-2/
mv -i apk-decompiled/* apk/
( apk/resources/classes*.dex are the same as apk/classes*.dex )
loaded apk/classes*.dex into decompiler.com, downloaded zips, extracted to apk/classes*/
mv -i classes*/ apk/
used Android Studio, profile or debug apk, loaded *.apk
- download & install android platform 28 sdk
- download plugin updates when prompted, restarted android studio when promptedo- built virtual device Pixel XL using Q atom (no google API or Google play), named AVD
since unable to run virtual x86 image within android studio within parallels, uninstalled android studio, reinstalled, no help
installed Android 7 as a Parallels virtual machine
in AVM, Settings->Developer Options->USB Debugging on
set windows path to include %LOCALAPPDATA%\Android\sdk\platform-tools
restart android studio
in android studio terminal, adb connect 192.168.64.3
When android studio connected to device, run apk, which will install future fight and start it; download update files when recommended.
however, unable to click on "Download" button, so tried again with Android-x86 9

could not get mff to run in parallels android emulator (download button never worked), so installed Google Play version on Mac Android Studio, signed in, used Gplay to install future fight, restored account from Facebook, installed all patches when prompted, downloaded all Data from settings, exit game
got files/directories: via adb shell, adb shell pm list packages | grep netmarble, adb shell pm path com.netmarble.mherosgb:
/data/app/~~493DhfzldxyauWfofN2Syg==/com.netmarble.mherosgb-5h4QgwLp0OjncIsIOkxU4w==/base.apk
/data/app/~~493DhfzldxyauWfofN2Syg==/com.netmarble.mherosgb-5h4QgwLp0OjncIsIOkxU4w==/split_config.x86.apk

built new avd with all the same except not google play
adb install-multiple base.apk split_config.x86.apk
started, updated and connected as prompted, connected to account
settings-->download all
exit game
got all files findable by root in a netmarble path, zipped to allfiles.tar.gz
(some nmss sockets unable to be taken)
compared base & split apk from google play avd to new one in allfiles, same, deleted the former
compared base & split apk to downloaded one, same except for manifests and splits0.xml files
(also made sure there were no other files with user u0_a149, group u0_a149, or group u0_a149_cache)
unpacked allfiles.tar.gz to device/
pruned subtrees that were identical, got down to just the /data directory

decompiled .apk files and the .dex files within them to decompiled/, combined (mostly) the split and base dirs, combined the classes dirs

need to decompile odex and vdex files; base.vdex contained only (optimized) copies of the classes.dex and classes2.dex files. (used vdexExtractor) Used baksmali, then smali, then decompiler.com to decompile base.odex->out(smalis)->out.dex->odex-sources/, merged new files (constants et al.) with decompiled/base/sources. All the rest are at least cosmetically different (fail cmp), left in decompiled/base-odex/sources.

need to check (a separate copy of) decompiled and/or device for assets/bundles

Asset Studio:
decompiled/ : a few text assets including localization, RPC?, sounds, scenes?, fonts (including confirmation primary font is Exo Condensed and (maybe) Arial, Visitor TT1 Extended, and Exo CJKs)
device/ :

(uTinyRipper doesn't seem to have functionality not in AssetStudio, UAE crashes a lot but gives idea hex editor may be useful) DevXUnity tools may be useful for regenerating Unity packages, but this is not in the free versions.

obtained apktool, used to decompile base.apk, should use this and compare to decompiler.com
unzipped apk files to base.apk-unzipped and split.apk-unzipped. Used Il2CppDumper, selected split.apk-unzipped/lib/x86/libil2cpp.so then base.apk-unzipped/assets/bin/Data/Managed/Metadata/global-metadata.dat; (could also use command line Il2CppDumper.exe libil2cpp.so global-metadata.dat output-directory/

loaded device/data/media/0/Android/data/com.netmarble.mherosgb/files/bundle into AssetStudioGUI (which took a very long time)

When libil2cpp.so calls PluginsCommon, retype as PluginsCommonForAndroid to get
proper method name/function, then check jadx decompiled
sources/com/seed9/common/Common.java

We make assumptions where needed that we're using a final "distribution" version
of the software, in the "global" (i.e., not china or tencent) setting

Common dead ends: GameObject_AddComponent...

Reverse Engineered Program Flow:

SceneTitle.Start() {
	SceneTitle.CheckServer() {
		PacketTransfer.SetServerData( scene SceneTitle ) {
			url = PatchSystem.get_url() {
				PatchSystem.CreateUrl() {
					BuildType  = Define.get_BuildType = BUILD_TYPE__Enum.GLOBAL (0)
					BuildOptions = Define.get_BuildOptions = BUILD_OPTIONS__Enum.DIST (4)
					baseUrl = PatchSystem.get_base_url() = PatchSystem.GetBaseUrl() = http://mheroesgb.gcdn.netmarble.com/mheroesgb/
					return baseUrl + DIST/Android/
				}
			}
			filepath = ServerInfo.GetRemoteFilePath() {
				filepath = "v" + bundleVersion + "/"
				filepath = filepath + ServerInfo.GetFileName() { return "server_info.txt" }
				filepath = filepath + "?p=" + CommonUtil.GetRandomInt()
				return filepath
			}
			WWWUtil.Get( param = url + filepath, scene, successMethod = "SetServerDataOK", failMethod = "", isLock = true, sendOption = 0, sendtotargetscene = false, timeout, _retry = false, receiveresultwhenunlock = true, useFastJson = false, forceNotSequence = false, disableProgressUI = false ) {
				wwwType = 1
				if param startswith http {
					url = param
					isGamePacket = false
					isSequenceProcess = false
				} else {
					WWWUtil.AddDefaultPacketParameter( param ) {

					}
					key = packetkey = CryptUtil.get_packetKey() {

					}
					if packetkey is nullorempty
						key = CryptUtil.get_aesKey() + CryptUtil.get_aesKey()
					encryptedParam = CryptUtil.AESEncrypt( param, key, IsKeyIvSame = true ) {

					}
					WWWUtil.MakeHeader( sessionId, encryptedParam.length ) {

					}
					contents = header + encryptedParam
					url = ServerInfo.get_URL() + "FF"
					isGamePacket = true
					isSequenceProcess = true
					encoded = true
					form = WWWForm.AddBinaryData( fieldname = bin, contents, filename = bin, mimetype = application / octet - stream ) {

					}
				}
				failedReason = 0
				MyData.RestoreAllPrevData()
				WWWUtil.GetRoutine_1() {
					// via MonoBehaviour.StartCoroutine(): WWWUtil.GetRoutine_c_Iterator1.MoveNext() { // this is a guess
					if isSequenceProcess {
						// add the request( WWWData ) to the WWWUtil data stack then do the next request in the stack via WWWUtil.GetRountine_internal like below
					} else {
						// just do the request via
						WWWUtil.GetRountine_internal() {
							// via MonoBehaviour.StartCoroutine() WWWUtil.GetRountine_internal_c_Iterator0.MoveNext() { // this is a guess
							// specifically for WWWType = 1
							// BestHTTP package HTTPRequest( url, POST )
							HTTPRequest.SetFields( form )
							HTTPRequest.Send()
							bytes = HTTPRequest.get_Response().get_Data()
							WWWUtil.OnRequestFinished( data, error, bytes ) {
								if failedReason == 0 && error is nullorempty {
									if IsGamePacket {
										errors = WWWUtil.Parse( CryptUtil.PacketDecode( bytes, WWWUtil.UsePacketKeyFirst( param ) ), data, descRef )
										if errors is nullorempty {
											WWWUtil.ResultOK( data, packetdecode, fastjson ) {
												WWWUtil.SendResult( scene, successmethod, packetdecode, sendoption, sendtotargetscene, data, fastjson, byte[] bytes = null, bool isCache = false ) {
													If sendtoTargetScene == 0 {
														PacketTransfer( aka Component_1 ).SendMessage( successmethod, WWWResult, SendMessageOptions.Enum.DontRequireReceiver ) // just guessing this calls PacketTransfer.successMethod()
													} else {
														Scene( aka GameObject ).SendMessage( successmethod, wwwresult, sendmessageoptions * *enum.DontRequireReceiver) // just guessing this calls scene.successMethod
													}
												}
												HeroList_UpdateAll()
											}
										} else {
											WWW.ResultFail( data, errors, fastjson, packetdecode )
										}
									} else {
										byteString = CryptUtil.ByteToString(bytes)
										byteString = WWW.UnEscapeURL(byteString)
										WWWUtil.ResultOK(data,resultString,FastJsonObject desc = null)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
PacketTransfer.SetServerDataOK(WWWResult result) {
	PacketTransfer.NotifyResult(scene,"SetServerDataOK",result->text) {
		scene.sendmessage("SetServerDataOK",text,SendMessageOptions__Enum_DontRequireReceiver) // guessing this calls
			SceneTitle.SetServerDataOK(text) {
				ServerInfo.ParseVersionFile(text) {
					ServerInfo.ParseVersionFileCDN(text) {
						serverResponse = JsonParser.Parse(text, typeof Server_Response)
						PatchConfig.Init() // Configures low device resource usage if necessary
						ServerInfo.set_data(null) { ServerInfo.staticfields.data_ = null }
						serverList = serverResponse.server_list
						foreach server in serverList {
							selectServer = serverResponse.select_server
							if server.type == selectServer.type {
								ServerInfo.set_data(server);
								break;
							}
						}
						serverData = ServerInfo.get_data()
						if serverData == null ServerInfo.set_data(serverList[0]) {
							ServerInfo.data = server
							ServerInfo.contentServer = server.detail.content
						}
						ServerInfo.get_contentBuild() {
							ServerInfo.contentBuild_ = new ContentOnOffForBuild() // Includes some hardcoded settings
						}
					}
				}
				SceneTitle.NextUpdateInfoViewState() // continue on to further startup
			}
	}
}

// (Back up to SceneTitle__SetServerDataOK)—>SceneTitle__ShowUpdateInfoView
// (Callback)SceneTitle.<ShowUpdateInfoView>m_0();
// Showtermsofservice
// packettransfer__checkaccount
// packettransfer$$Checkaccountok
// sceneTitle$$oncheckaccountok
// scenetitle__showtermsofservice (again)
// SceneTitle$$SignIn
// Plugins__signin
// - Get access token

// 	Searching for gameCode/accessToken:
// ConfigurationImpl.loadXml
// setGameCode
// gameCode
// GMC2Network.getConstants
// Configuration.copy
// gameToken
// ChannelNetwork.INSTANCE.getChannel(… gameCode, … gameToken,…)
// LogIm[pl: I_GameCode netmarbles?
// SessionImpl: JSONObject3
// NetMarlbeLog
// AuthDataManager.KEY_GAME_TOKEN
// Service$$GetGameCode: not obviously called by anything, returns only mherosgb (without e)
// curl -H "gameCode: mherosgb" -v 'Https://apis.netmarble.com/mobileauth/v2/players/01A703E413294D38825A102A6E5E943E/deviceKeys/9C088F867BAB426987D6DA877B782F44/accessToken'
// - gameToken:
//     - Java doSignIn result JSON object accessToken ->SessionNetwork.signIn(gatewayUrl, playerId, DeviceKey, GameCode, AndroidId, CountryCode, str, callback)
//     - https://apis.netmarble.com/, playerID, devicekey, Gamecode mherosgb?, androidID random uuid, US,
//     - Https://apis.netmarble.com/mobileauth/v2/players/01A703E413294D38825A102A6E5E943E/deviceKeys/9C088F86-7BAB-4269-87D6-DA877B782F44/accessToken
// Back up the chain to SceneTitle$$OnSignIn
// SceneTitle\$\$NextStepByNetmarbleSignIn->
// SceneTitle__NextStepByConnect->
// SceneTitle$$CheckCertificationWithCondition->
// SceneTitle\$\$PreLogin->
// 	ServerDetail__get_WebServerSSL: returns websvr_ssl (https://mherosgb.netmarble.com/NM/)
// ServerInfo__get_SslURL:  calls get_WebServerSSL
// URL: concat surl, “PreLogin”: https://mherosgb.netmarble.com/NM/PreLogin
// PacketTransfer__PreLogin: gathers form data information, calls WWWUtil_PostSSL
// Form data:
// - cID: PluginsNetmarbleS$$get_PlayerId; set_PlayerId (general: random UUID with -s removed, all upper case)
// - dID: GetDeviceId2; mine is in ff_openudid.xml, general:
//     - str=android.os.SystemProperties.ro.serialno or 0
//     - str2=same
//     - string2=UnityPlayer.currentActivity.getContentResolver() android_id or 0
//     - str3=0,0,string2
//     - str4=str,str2,string2 if all 0, randomUUID()
//     - deviceName = Devices.getDeviceName() = e.g., “HTC One”
//     - md5(str3+deviceName)”-“md5(str4+deviceName)
//     - Simple valid = md5(“0,0,0HTC One”)”-“md5(randomUUID+”HTC One”)
// - gameToken: (from above apis.netmarble.com URL)
// - platform: android
// - ver: 6.2.0
// - lang: en(?)
// - country: US(?)
// - ds: CommonUtil$$IsDaylightSavingTime 1(?)
// - client_ip: get_ipAddress 127.0.0.1(?)
// - srvPush: get_allowGame(get_PushNotification) 1(?)
// - de: get_deviceModel “HTC One” (?)
// - pan: Panho$$isEnableLimit(0,1,0) 0(?)
// - pan2: Panho$$isEnable(0,1,0) 0(?)
// - timeZone: -08:00(?)
// WWWUtil__PostSSL:  processes & submits form data; on success passes result to PacketTransfer__PreLoginOK
// Form processing:
// base url=Https://mheroesgb.netmarble.com/NM/PreLogin?cKey=fRealtimeSinceStartup(sec)

// PacketTransfer__PreLogin: WWWUtil__PostSSL
// - Get text key
// —>PreLoginOK:
// 	PacketTransfer__PreLoginOK: sets:
// textKey: WWWResult->Json->key=tek
// packetKey: concat(WWWresult—>JSON->key=sessID->last 8 characters if length > 19, WWWresult->Json->key=cID->last 8 characters)
// CryptUtil__set_textKey(,tek,):
//		pk = CryptUtil__get_packetKey
//		textKey_ = CryptUtil__AESEncrypt(,tek,pk,)-->
//		textKey_ = CryptUtil__XOREncode(,textKey_,)
// - Get asset
// - Decrypt asset
// - Format csv vs load into dbtable

// Maybe: - SceneTitle__Login_c__Iterator1__MoveNext (maybe from SceneTitle::Login)
// - DBTable__LoadDB
//     - Various DBTable__get_*Table
//         - TableUtility__Load_*_
//             - TableUtility__GetAssetPath (by type)
//                 - TableUtility__GetPathWithoutExtension + “.asset”
//                     - Which seems to dynamically determine loader to call, <type>$$LoadCSV

/*****************************************************
// Eventual goal: parse supplied text assets to CSV
// *****************************************************/

// ISO8Set**LoadCSV() -->
// CSVLoader**Load(,,text/data/ISO8*SET.csv,) -->
// AssetBundleLoader\_\_Load_TextAsset*(,text/data/ISO8-SET.csv,) -->
// AssetBundleLoader**LoadAsset(, text/data/ISO8_SET.csv,typeof(TextAsset),) -->
// AssetBundleMgr**LoadAsset(,text/data/ISO*SET.csv,type,) (or UnityEngine_Resources**Load if not found)-->
// AssetBundleMrg**LoadAsset(,text,text/data/ISO8_SET.csv,type,false,) -->
// AssetBundleMgr_AssetBundleData**LoadAsset(assetBundle, text/data/ISO8_SET.csv,type,) -->
// UnityEngine_AssetBundle**LoadAsset(assetBundle, text/data/ISO8_SET.csv,type,), returning the TextAsset back
// up the chain to CSVLoader**Load:
// str = UnityEngine_TextAsset**get_text(textAsset,);
// CSVLoader**LoadFromString(textAsset,readvalue,str,0)-->
// CryptUtil**AESDecryptText(,str,) [0x010a1fc9]-->
// key = CryptUtil\_\_get_textKey(,)
// textKey* = CryptUtil*TypeInfo->CryptUtil_c-->CryptUtil_StaticFields-->textKey*
// packetKey = CryptUtil**get_packetKey(,) -->
// PluginsCommonForAndroid-->get_packetKey -->
// (decompiled) getPacketKey
// textKey = CryptUtil**XORDecode(,textKey*,)
// textKey = CryptUtil\_\_AESDecrypt(,textKey,packetKey,) (or, if packetKey is null, just textKey*)
// CryptUtil\_\_AESDecrypt(,str,key,) [0x010a055b] ->

// from (decompiled) classes/sources/com/seed9/unityplugins/UnityPluginCommon.java:
// AesKey = "!YJKLNGD"

// packetKey:

// PacketTransfer__PreLoginOK: (along with setting userId, sessionId, isEmailRegistered, cID, isNewAccount,apkToken,admit,textKey)
// If sessionId length >=20, take last 8 chars only; for
// (Last8 of sessionId)^2->
// CryptUtil__set_packetKey -> PluginsCommonForAndroid__set_PacketKey —>decompiled setPacketKey
// When getting packetKey, if null, concat(aesKey,aesKey) is used instead in WWWUtil__Get, but not in CryptUtil__get/set_textKey. CryptUtil$$PacketDecode tries the AESkey^2 first.

// CryptUtil\_\_set_textKey(,string,) (from PacketTransfer$$PreLoginOK)
// Setting textKey\_ in CryptUtil_TypeInfo:
// Start at CSVLoader\_\_LoadFromString with CryptUtil_TypeInfo initializer (43ef37c, in .bss) (starting at 10a45d7):
// XOREncode/XORDecode uses xor_table in CryptUtil_TypeInfo, but since it uses it for each,
// can't I just use any table?

// For this program, reorganizing based on dependencies, so the idea is just to
// call GetCSV(Type) or something similar (maybe even an umbrella GetAllCSV or the like)
// and determine which parts need to be called to simulate a login and download or
// otherwise obtain needed data. Would also make a "force" flag to update all the date

// Where reasonable below, methods have the same name as the function's basename
// in libil2cpp.so (without having the namespace, it may combine parts from multiple
// namespaces)

//TablePath = text/data/
//TableName = TableNameAttribute/CSVTableNameAttribute
//ext = csv
// \*/

/\* Most are simple base64-encoded strings the base-64 strings when decoded have a ^@ (null) before every character after every character, presumably due to the use of 16-bit characters? Should effectively strip when possible or otherwise work around Many are within the device/data/media/0/Android/data/com.netmarble.mherosgb/files/bundle/text asset bundle (These have already been decoded to output/) Others appear to be identified by TableName/TableNameAttribute/CSVTableNameAttribute but I don't yet know where they're stored TableNameAttribute and CSVTableNameAttribute appear to be set by their respective ctors called by various anonymous functions with names/"filenames" strings from .rodata

The simple \*.csv textassets can be exported and (when necessary), base64 decoded with only command line base64 -D -i filename Without rigorous testing, the TableNames appear to be MonoBehavior/MonoScript pairs in bundle/text, though I'm not sure yet about decoding; need to better eval, e.g., loading IntAbilityGroupDataDictionary from text/data/action_ability.asset

Appears UABE can extract these to JSON files Perhaps these are the ones that are too large for CSVs?

Some are: TableNameAttribute: ACTION_AUTO_ABILITY ALLIANCE_EMBLEM_BG ALLIANCE_EMBLEM_BORDER ALLIANCE_EMBLEM_SYMBOL APPLY_OTHER_BY_TARGET ARENA_PARTICIPATION_RANK_REWARD HERO_SKILL MOB_SKILL GAME_CONFIG TOURNAMENT_EVENT_BATTLE_CONFIG SHADOWLAND_BATTLE_CONFIG SUPER_COOP_BATTLE_CONFIG PVP_BALANCE DOMINATION_BATTLE_CONFIG DANGER_ROOM_CONFIG ACHIEVEMENTS ALLIANCE_ACHIEVEMENTS INTRUSION_TEAMUP INTRUSION_BOSS LOADING_TIP LOADING_TIP_LIST WORLD_BOSS_REWARD WORLD_BOSS_HAVE_BONUS URU_PREMIUM URU_COMPOSE TOURNAMENT_EVENT_REWARD SUPER_COOP_QUEST SUMMON SUBTYPE_GROUP_ID COUNTRY_LATLON ERR_PROCESS DOMINATION_MOB STORY_CAMPAIGN_TRAIT STORY_CAMPAIGN_LEVEL STORY_CAMPAIGN_HERO STAGE_FIRST_CLEAR_REWARD StageEnterBundleList TEAM_LEAGUE_RANK_REWARD TEAM_LEAGUE TEAM_LEAGUE_CONDITION SPECIAL_GEAR_ICON ... and lots more

CSVTableNameAttribute: ACTION_ABILITY ALLIANCE_EMBLEM ARENA_RANK_REWARD HERO_SKILL MOB_SKILL RANDOM_OPTION ADD_ABILITY_LIST

TableUtility**GetCSVPaths: text/data/ + TableName + .csv TableUtility**GetAssetPath: text/data/ + TableName + .asset

\*/

/_ Other interesting things: GlobalConstants\_\_\_ctor Maybe everything in DBTable->Fields _/
